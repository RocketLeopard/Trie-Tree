# Trie-Tree
Trie树，又称字典树，单词查找树或者前缀树，是一种用于快速检索的多叉树结构，如英文字母的字典树是一个26叉树，数字的字典树是一个10叉树。

## 基本性质
1. 根节点不包含字符，除根节点意外每个节点只包含一个字符。
2. 从根节点到某一个节点，路径上经过的字符连接起来，为对应的字符串。
3. 每个节点的所有子节点包含的字符串不相同。

## 基本实现
1. 每个子节点都预分配一个数组（根据字母字典树或者数字字典树分配大小），使用ASCII编码表作为排序的标号。  
2. 每个子节点预分配一个哈希对象。  
3. 每个子节点使用链表存储，链表的next指针指向下一个子节点。

### 优缺点
1. 使用数组，优点能让字典树有序（使用了ASCII编码作为排序下标），缺点是数组大小需要预先分配空间。并不是所有节点都会有很多子节点，所以这种方式浪费的空间太多。并且，因为预先分配了空间，比较难做自动扩容。    
2. 使用哈希对象，优点是不用预先分配空间，数据量小的时候不用浪费空间，空间不足可以自动扩容，缺点是字典树无法保持字典序。  
3. 使用链表，优点也是不用预先分配空间，可以根据需要动态添加节点节省空间，但是缺点但是检索的时候需要遍历所有的子节点，增加了时间复杂度。  
4. 综上所述，企业级应用一般是需要做字典序排序，并且数据量庞大，数组预分配的空间基本都会被使用到，因此一般首选数组作为基本实现。  

## 高级实现
1. 可以采用双数组（Double-Array）实现。利用双数组可以大大减小内存使用量  
这是什么鬼啊？？？还没弄明白，埋坑
2. 将末尾一些只有一个子节点的节点，可以进行合并，但是增加了编码的难度。

## Trie树复杂度分析
1. 构建字典树的时间复杂度为O(M)，其中M为所有字符串长度之和  
2. 插入、查找的时间复杂度均为O(N)，其中N为字符串长度
3. 空间复杂度最坏为O(M)，其中M为所有字符串长度之和，非常庞大（可采用双数组实现改善）  

## 应用
1. 字符串检索  
例如可以把一些敏感词构建成一棵Trie树，可以用于论坛贴吧等UGC内容的敏感词过滤
2. 字符串最长公共前缀  
Trie树利用多个字符串的公共前缀来节省存储空间，反之，当我们把大量字符串存储到一棵Trie树上时，我们可以快速得到某些字符串的公共前缀
3. 搜索框sug提示
在搜索框输入内容的时候，可以根据输入的内容作为公共前缀在词库里检索内容作为sug提示
